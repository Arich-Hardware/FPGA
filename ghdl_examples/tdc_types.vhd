-- This file was auto-generated by YML2HDL toll.
-- https://gitlab.com/tcpaiva/yml2hdl

library IEEE;

use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

package tdc_types is

  procedure assign(
    variable y : out std_logic_vector;
    constant y0 : in integer;
    constant x : in std_logic_vector;
    constant x0 : in integer;
    constant l : in integer);

  function len(x: std_logic) return natural;
  function len(x: std_logic_vector) return natural;
  function len(x: unsigned) return natural;
  function len(x: signed) return natural;
  function len(x: natural) return natural;

  function structify(x: std_logic_vector; t: signed) return signed;
  function structify(x: std_logic_vector; t: unsigned) return unsigned;
  function structify(x: std_logic_vector; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: integer) return integer;
  function structify(x: std_logic_vector; t: std_logic) return std_logic;

  function vectorify(x: signed; t: std_logic_vector) return std_logic_vector;
  function vectorify(x: unsigned; t: std_logic_vector) return std_logic_vector;
  function vectorify(x: std_logic_vector; t: std_logic_vector) return std_logic_vector;
  function vectorify(x: integer; t: std_logic_vector) return std_logic_vector;
  function vectorify(x: std_logic; t: std_logic_vector) return std_logic_vector;

  function nullify(y: std_logic) return std_logic;
  function nullify(y: std_logic_vector) return std_logic_vector;
  function nullify(y: unsigned) return unsigned;
  function nullify(y: signed) return signed;
  function nullify(y: integer) return integer;

  constant TDC_COARSE_BITS : integer := 6;

  constant TDC_PHASE_BITS : integer := 2;

  constant TDC_TRIG_BITS : integer := 3;

  constant NUM_TDC_BUFFERS : integer := 2;

  constant TRIGGER_WINDOW : integer := 25;

  constant TDC_TIMEOUT_BITS : integer := 7;

  constant TDC_TIMEOUT : integer := 35;

  type tdc_hit_rt is record
    le_time : unsigned(TDC_COARSE_BITS-1 downto 0);
    le_phase : std_logic_vector(TDC_PHASE_BITS-1 downto 0);
    te_time : unsigned(TDC_COARSE_BITS-1 downto 0);
    te_phase : std_logic_vector(TDC_PHASE_BITS-1 downto 0);
  end record tdc_hit_rt;
  function len(x: tdc_hit_rt) return natural;
  function vectorify(x: tdc_hit_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: tdc_hit_rt) return tdc_hit_rt;
  function nullify(t: tdc_hit_rt) return tdc_hit_rt;

  type tdc_buffer_rt is record
    timeout : unsigned(TDC_TIMEOUT_BITS-1 downto 0);
    hit : tdc_hit_rt;
    valid : std_logic;
    busy : std_logic;
    active : std_logic;
    readme : std_logic;
  end record tdc_buffer_rt;
  function len(x: tdc_buffer_rt) return natural;
  function vectorify(x: tdc_buffer_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: tdc_buffer_rt) return tdc_buffer_rt;
  function nullify(t: tdc_buffer_rt) return tdc_buffer_rt;

  type tdc_buffer_group_rt is array(NUM_TDC_BUFFERS-1 downto 0) of tdc_buffer_rt;
  function len(x: tdc_buffer_group_rt) return natural;
  function vectorify(x: tdc_buffer_group_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: tdc_buffer_group_rt) return tdc_buffer_group_rt;
  function nullify(x: tdc_buffer_group_rt) return tdc_buffer_group_rt;

  type tdc_output_rt is record
    hit : tdc_hit_rt;
    trigger_number : unsigned(TDC_TRIG_BITS-1 downto 0);
    glitch : std_logic;
    error : std_logic;
  end record tdc_output_rt;
  function len(x: tdc_output_rt) return natural;
  function vectorify(x: tdc_output_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: tdc_output_rt) return tdc_output_rt;
  function nullify(t: tdc_output_rt) return tdc_output_rt;

end package tdc_types;

------------------------------------------------------------

package body tdc_types is

  procedure assign(
    variable y : out std_logic_vector;
    constant y0 : in integer;
    constant x : in std_logic_vector;
    constant x0 : in integer;
    constant l : in integer) is
    variable tmp : std_logic_vector(y'range);
  begin
    for j in 0 to l-1 loop
      tmp(j+y0) := x(j+x0);
    end loop;
    y := tmp;
  end procedure assign;
  function len(x: std_logic) return natural is
  begin
    return 1;
  end function len;
  function len(x: std_logic_vector) return natural is
  begin
    return x'length;
  end function len;
  function len(x: unsigned) return natural is
  begin
    return x'length;
  end function len;
  function len(x: signed) return natural is
  begin
    return x'length;
  end function len;
  function len(x: natural) return natural is
  begin
    return 32;
  end function len;

  function structify(x: std_logic_vector; t: signed) return signed is
    variable y: signed(t'range);
  begin
    y := signed(x);
    return y;
  end function structify;
  function structify(x: std_logic_vector; t: unsigned) return unsigned is
    variable y: unsigned(t'range);
  begin
    y := unsigned(x);
    return y;
  end function structify;
  function structify(x: std_logic_vector; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
  begin
    assign(y, t'low, x, x'low, x'length);
    return y;
  end function structify;
  function structify(x: std_logic_vector; t: integer) return integer is
    variable y: integer;
  begin
    y := to_integer(unsigned(x));
    return y;
  end function structify;
  function structify(x: std_logic_vector; t: std_logic) return std_logic is
    variable y: std_logic;
  begin
    y := x(x'low);
    return y;
  end function structify;

  function vectorify(x: signed; t: std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(x);
  end function vectorify;
  function vectorify(x: unsigned; t: std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(x);
  end function vectorify;
  function vectorify(x: std_logic_vector; t: std_logic_vector) return std_logic_vector is
  begin
    return x;
  end function vectorify;
  function vectorify(x: integer; t: std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(to_unsigned(x, 32));
  end function vectorify;
  function vectorify(x: std_logic; t: std_logic_vector) return std_logic_vector is
    variable y: std_logic_vector(t'range);
  begin
    y(y'low) := x;
    return y;
  end function vectorify;

  function nullify(y: std_logic) return std_logic is
  begin
      return '0';
  end function nullify;
  function nullify(y: std_logic_vector) return std_logic_vector is
  begin
      return (y'range => '0');
  end function nullify;
  function nullify(y: unsigned) return unsigned is
  begin
    return to_unsigned(0, y'length);
  end function nullify;
  function nullify(y: signed) return signed is
  begin
    return to_signed(0, y'length);
  end function nullify;
  function nullify(y: integer) return integer is
  begin
    return 0;
  end function nullify;

  function len(x: tdc_hit_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.le_time);
    l := l + len(x.le_phase);
    l := l + len(x.te_time);
    l := l + len(x.te_phase);
    return l;
  end function len;
  function vectorify(x: tdc_hit_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      y(left to left+len(x.le_time)-1) := vectorify(x.le_time, y(left to left+len(x.le_time)-1));
      left := left + len(x.le_time);
      y(left to left+len(x.le_phase)-1) := vectorify(x.le_phase, y(left to left+len(x.le_phase)-1));
      left := left + len(x.le_phase);
      y(left to left+len(x.te_time)-1) := vectorify(x.te_time, y(left to left+len(x.te_time)-1));
      left := left + len(x.te_time);
      y(left to left+len(x.te_phase)-1) := vectorify(x.te_phase, y(left to left+len(x.te_phase)-1));
    else
      y(left downto left-len(x.le_time)+1) := vectorify(x.le_time, y(left downto left-len(x.le_time)+1));
      left := left - len(x.le_time);
      y(left downto left-len(x.le_phase)+1) := vectorify(x.le_phase, y(left downto left-len(x.le_phase)+1));
      left := left - len(x.le_phase);
      y(left downto left-len(x.te_time)+1) := vectorify(x.te_time, y(left downto left-len(x.te_time)+1));
      left := left - len(x.te_time);
      y(left downto left-len(x.te_phase)+1) := vectorify(x.te_phase, y(left downto left-len(x.te_phase)+1));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: tdc_hit_rt) return tdc_hit_rt is
    variable y: tdc_hit_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.le_time := structify(x(left to left+len(y.le_time)-1), y.le_time);
      left := left + len(y.le_time);
      y.le_phase := structify(x(left to left+len(y.le_phase)-1), y.le_phase);
      left := left + len(y.le_phase);
      y.te_time := structify(x(left to left+len(y.te_time)-1), y.te_time);
      left := left + len(y.te_time);
      y.te_phase := structify(x(left to left+len(y.te_phase)-1), y.te_phase);
    else
      y.le_time := structify(x(left downto left-len(y.le_time)+1), y.le_time);
      left := left - len(y.le_time);
      y.le_phase := structify(x(left downto left-len(y.le_phase)+1), y.le_phase);
      left := left - len(y.le_phase);
      y.te_time := structify(x(left downto left-len(y.te_time)+1), y.te_time);
      left := left - len(y.te_time);
      y.te_phase := structify(x(left downto left-len(y.te_phase)+1), y.te_phase);
    end if;
    return y;
  end function structify;
  function nullify(t: tdc_hit_rt) return tdc_hit_rt is
  variable y: tdc_hit_rt;
  begin
    y.le_time := nullify(t.le_time);
    y.le_phase := nullify(t.le_phase);
    y.te_time := nullify(t.te_time);
    y.te_phase := nullify(t.te_phase);
    return y;
  end function nullify;

  function len(x: tdc_buffer_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.timeout);
    l := l + len(x.hit);
    l := l + len(x.valid);
    l := l + len(x.busy);
    l := l + len(x.active);
    l := l + len(x.readme);
    return l;
  end function len;
  function vectorify(x: tdc_buffer_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      y(left to left+len(x.timeout)-1) := vectorify(x.timeout, y(left to left+len(x.timeout)-1));
      left := left + len(x.timeout);
      y(left to left+len(x.hit)-1) := vectorify(x.hit, y(left to left+len(x.hit)-1));
      left := left + len(x.hit);
      y(left to left+len(x.valid)-1) := vectorify(x.valid, y(left to left+len(x.valid)-1));
      left := left + len(x.valid);
      y(left to left+len(x.busy)-1) := vectorify(x.busy, y(left to left+len(x.busy)-1));
      left := left + len(x.busy);
      y(left to left+len(x.active)-1) := vectorify(x.active, y(left to left+len(x.active)-1));
      left := left + len(x.active);
      y(left to left+len(x.readme)-1) := vectorify(x.readme, y(left to left+len(x.readme)-1));
    else
      y(left downto left-len(x.timeout)+1) := vectorify(x.timeout, y(left downto left-len(x.timeout)+1));
      left := left - len(x.timeout);
      y(left downto left-len(x.hit)+1) := vectorify(x.hit, y(left downto left-len(x.hit)+1));
      left := left - len(x.hit);
      y(left downto left-len(x.valid)+1) := vectorify(x.valid, y(left downto left-len(x.valid)+1));
      left := left - len(x.valid);
      y(left downto left-len(x.busy)+1) := vectorify(x.busy, y(left downto left-len(x.busy)+1));
      left := left - len(x.busy);
      y(left downto left-len(x.active)+1) := vectorify(x.active, y(left downto left-len(x.active)+1));
      left := left - len(x.active);
      y(left downto left-len(x.readme)+1) := vectorify(x.readme, y(left downto left-len(x.readme)+1));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: tdc_buffer_rt) return tdc_buffer_rt is
    variable y: tdc_buffer_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.timeout := structify(x(left to left+len(y.timeout)-1), y.timeout);
      left := left + len(y.timeout);
      y.hit := structify(x(left to left+len(y.hit)-1), y.hit);
      left := left + len(y.hit);
      y.valid := structify(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.busy := structify(x(left to left+len(y.busy)-1), y.busy);
      left := left + len(y.busy);
      y.active := structify(x(left to left+len(y.active)-1), y.active);
      left := left + len(y.active);
      y.readme := structify(x(left to left+len(y.readme)-1), y.readme);
    else
      y.timeout := structify(x(left downto left-len(y.timeout)+1), y.timeout);
      left := left - len(y.timeout);
      y.hit := structify(x(left downto left-len(y.hit)+1), y.hit);
      left := left - len(y.hit);
      y.valid := structify(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.busy := structify(x(left downto left-len(y.busy)+1), y.busy);
      left := left - len(y.busy);
      y.active := structify(x(left downto left-len(y.active)+1), y.active);
      left := left - len(y.active);
      y.readme := structify(x(left downto left-len(y.readme)+1), y.readme);
    end if;
    return y;
  end function structify;
  function nullify(t: tdc_buffer_rt) return tdc_buffer_rt is
  variable y: tdc_buffer_rt;
  begin
    y.timeout := nullify(t.timeout);
    y.hit := nullify(t.hit);
    y.valid := nullify(t.valid);
    y.busy := nullify(t.busy);
    y.active := nullify(t.active);
    y.readme := nullify(t.readme);
    return y;
  end function nullify;

  function len(x: tdc_buffer_group_rt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function vectorify(x: tdc_buffer_group_rt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i+l-1+x'low;
        b := l*i+x'low;
        y(b to a) := vectorify(x(i), y(b to a));
      end loop;
    else
      for i in x'range loop
        a := l*i+l-1+x'low;
        b := l*i+x'low;
        y(a downto b) := vectorify(x(i), y(a downto b));
      end loop;
    end if;
    return y;
  end function vectorify;
  function structify(x: std_logic_vector; t: tdc_buffer_group_rt) return tdc_buffer_group_rt is
    variable y : tdc_buffer_group_rt;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i+l-1+x'low;
        b := l*i+x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i+l-1+x'low;
        b := l*i+x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function nullify(x: tdc_buffer_group_rt) return tdc_buffer_group_rt is
    variable y : tdc_buffer_group_rt;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;

  function len(x: tdc_output_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.hit);
    l := l + len(x.trigger_number);
    l := l + len(x.glitch);
    l := l + len(x.error);
    return l;
  end function len;
  function vectorify(x: tdc_output_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      y(left to left+len(x.hit)-1) := vectorify(x.hit, y(left to left+len(x.hit)-1));
      left := left + len(x.hit);
      y(left to left+len(x.trigger_number)-1) := vectorify(x.trigger_number, y(left to left+len(x.trigger_number)-1));
      left := left + len(x.trigger_number);
      y(left to left+len(x.glitch)-1) := vectorify(x.glitch, y(left to left+len(x.glitch)-1));
      left := left + len(x.glitch);
      y(left to left+len(x.error)-1) := vectorify(x.error, y(left to left+len(x.error)-1));
    else
      y(left downto left-len(x.hit)+1) := vectorify(x.hit, y(left downto left-len(x.hit)+1));
      left := left - len(x.hit);
      y(left downto left-len(x.trigger_number)+1) := vectorify(x.trigger_number, y(left downto left-len(x.trigger_number)+1));
      left := left - len(x.trigger_number);
      y(left downto left-len(x.glitch)+1) := vectorify(x.glitch, y(left downto left-len(x.glitch)+1));
      left := left - len(x.glitch);
      y(left downto left-len(x.error)+1) := vectorify(x.error, y(left downto left-len(x.error)+1));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: tdc_output_rt) return tdc_output_rt is
    variable y: tdc_output_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.hit := structify(x(left to left+len(y.hit)-1), y.hit);
      left := left + len(y.hit);
      y.trigger_number := structify(x(left to left+len(y.trigger_number)-1), y.trigger_number);
      left := left + len(y.trigger_number);
      y.glitch := structify(x(left to left+len(y.glitch)-1), y.glitch);
      left := left + len(y.glitch);
      y.error := structify(x(left to left+len(y.error)-1), y.error);
    else
      y.hit := structify(x(left downto left-len(y.hit)+1), y.hit);
      left := left - len(y.hit);
      y.trigger_number := structify(x(left downto left-len(y.trigger_number)+1), y.trigger_number);
      left := left - len(y.trigger_number);
      y.glitch := structify(x(left downto left-len(y.glitch)+1), y.glitch);
      left := left - len(y.glitch);
      y.error := structify(x(left downto left-len(y.error)+1), y.error);
    end if;
    return y;
  end function structify;
  function nullify(t: tdc_output_rt) return tdc_output_rt is
  variable y: tdc_output_rt;
  begin
    y.hit := nullify(t.hit);
    y.trigger_number := nullify(t.trigger_number);
    y.glitch := nullify(t.glitch);
    y.error := nullify(t.error);
    return y;
  end function nullify;

end package body tdc_types;
